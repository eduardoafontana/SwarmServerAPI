
@Styles.Render("~/Content/detail-box")
@Scripts.Render("~/bundles/detail-box")
@Scripts.Render("~/bundles/threejs")
@Scripts.Render("~/bundles/3dview")

<style>
    body, html {
        height: 100%;
        padding-bottom: 50px;
    }
    html, body, .container-fluid, .row, main, .canvasRenderRelativeSize {
        height: 100%;
    }
</style>
<script>
    function drawLine(x1, y1, z1, x2, y2, z2, hexColor) {
        var geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(x1, y1, z1));
        geometry.vertices.push(new THREE.Vector3(x2, y2, z2));

        var material = new THREE.LineBasicMaterial({ color: hexColor });

        return new THREE.Line(geometry, material);
    }

    function drawCubeOnGraph(positionX, positionZ, lines, hexColor, mostHighFileLine, group) {
        var height = lines * 50 / mostHighFileLine;

        var squareSize = 1;

        var ySize = height;
        var xSize = squareSize;
        var zSize = squareSize;

        var geometry = new THREE.BoxGeometry(xSize, ySize, zSize);
        var material = new THREE.MeshBasicMaterial({ color: hexColor });
        var cube = new THREE.Mesh(geometry, material);

        material.opacity = 0.5;
        material.transparent = true;

        var adjustToZeroAxisY = ySize / 2
        var margin = 0.5;
        var sizeWithMargin = margin + squareSize;

        cube.position.y = adjustToZeroAxisY;
        cube.position.x = sizeWithMargin * positionX;
        cube.position.z = sizeWithMargin * positionZ;

        cube.group = group;
        cube.initialCalculatedPositionX = cube.position.x;
        cube.initialCalculatedPositionZ = cube.position.z;
        cube.lines = lines;
        cube.xSize = xSize;
        cube.zSize = zSize;
        cube.isCube = true;
        cube.mostHighFileLine = mostHighFileLine;
        cube.canScaleChange = true;

        return cube;
    }

    function drawHideCubeButton(positionX, positionZ, height, hexColor, group) {
        var radius = 0.5;
        var topMargin = 0.5;
        var positionY = height;

        var geometry = new THREE.SphereGeometry(radius, 20, 20);
        var material = new THREE.MeshBasicMaterial({ color: hexColor });
        var sphere = new THREE.Mesh(geometry, material);

        material.opacity = 0.5;
        material.transparent = true;

        var margin = 0.5;
        var sphereSize = radius * 2; //diameter
        var sizeWithMargin = margin + sphereSize;

        sphere.position.y = radius + topMargin + positionY;
        sphere.position.x = sizeWithMargin * positionX;
        sphere.position.z = sizeWithMargin * positionZ;

        sphere.group = group;
        sphere.initialCalculatedPositionX = sphere.position.x;
        sphere.initialCalculatedPositionZ = sphere.position.z;
        sphere.radius = radius;
        sphere.topMargin = topMargin;
        sphere.isSphere = true;
        sphere.canHideRelated = true;
        sphere.canHighlightOnMouseOver = true;
        sphere.canScaleChange = true;

        return sphere;
    }

    function drawTorusOnGraph(positionX, positionZ, height, data, group) {
        var radius = 0.7;
        var topMargin = 0.5;

        var geometryTorus = new THREE.TorusGeometry(radius, 0.1, 100, 100);
        var materialTorus = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        var torus = new THREE.Mesh(geometryTorus, materialTorus);

        var margin = 0.1;
        var torusSize = radius * 2; //diameter
        var sizeWithMargin = margin + torusSize;
        var adjustToZeroAxisY = height / 2;

        torus.position.y = topMargin + adjustToZeroAxisY;
        torus.position.x = sizeWithMargin * positionX;
        torus.position.z = sizeWithMargin * positionZ;

        torus.rotation.x = 1.6; //flip to horizontal

        torus.group = group;
        torus.initialCalculatedPositionX = torus.position.x;
        torus.initialCalculatedPositionZ = torus.position.z;
        torus.data = data;
        torus.topMargin = topMargin;
        torus.isTorus = true;
        torus.canOpenDetailBox = true;
        torus.canHighlightOnMouseOver = true;
        torus.canScaleChange = true;

        return torus;
    }

    function drawTorusSquareOnGraph(positionX, positionZ, height, data, group) {
        var radius = 0.7;
        var topMargin = 0.5;

        var geometryTorus = new THREE.TorusGeometry(radius, 0.1, 100, 4);
        var materialTorus = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        var torus = new THREE.Mesh(geometryTorus, materialTorus);

        var margin = 0.1;
        var torusSize = radius * 2; //diameter
        var sizeWithMargin = margin + torusSize;
        var adjustToZeroAxisY = height / 2;

        torus.position.y = topMargin + adjustToZeroAxisY;
        torus.position.x = sizeWithMargin * positionX;
        torus.position.z = sizeWithMargin * positionZ;

        torus.rotation.x = 1.6; //flip to horizontal
        torus.rotation.z = 0.8; //rotate to equal cube node

        torus.group = group;
        torus.initialCalculatedPositionX = torus.position.x;
        torus.initialCalculatedPositionZ = torus.position.z;
        torus.data = data;
        torus.topMargin = topMargin;
        torus.isTorus = true;
        torus.canOpenDetailBox = true;
        torus.canHighlightOnMouseOver = true;
        torus.canScaleChange = true;

        return torus;
    }

    //function getRamdomColor() {
    //    return '#' + Math.floor(Math.random() * 16777215).toString(16);
    //}

    function onDocumentMouseMove(event) {
        var positions = document.body.getElementsByClassName("canvasRenderRelativeSize")[0].getBoundingClientRect();

        setMouseRelativePosition(event, positions);
    }

    function setMouseRelativePosition(eventAbsolute, relativePositions) {
        mouse.x = ((eventAbsolute.clientX - relativePositions.x) / getRelativeWidth()) * 2 - 1;
        mouse.y = - ((eventAbsolute.clientY - relativePositions.y) / getRelativeHeight()) * 2 + 1;
    }

    function onDocumentMouseDown(event) {
        var positions = document.body.getElementsByClassName("canvasRenderRelativeSize")[0].getBoundingClientRect();
        setMouseRelativePosition(event, positions);

        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObjects(scene.children);
        if (intersects.length > 0) {
            var intersect = intersects[0];

            if (intersect.object.canOpenDetailBox) {
                var box = document.getElementsByClassName("detail-box")[0];

                box.style.visibility = 'visible';

                var boxMain = box.getElementsByClassName("detail-box-main")[0];

                var wrapper = document.createElement('div');
                wrapper.innerHTML = intersect.object.data;

                boxMain.innerHTML = '';
                boxMain.appendChild(wrapper);
            }

            if (intersect.object.canHideRelated) {
                var cubeFromSphere = scene.getObjectById(intersect.object.cubeId, true);

                if (cubeFromSphere.visible)
                    cubeFromSphere.visible = false;
                else
                    cubeFromSphere.visible = true;
            }
        }
    }

    function getRelativeHeight() {
        return document.body.getElementsByClassName("canvasRenderRelativeSize")[0].offsetHeight;
    }

    function getRelativeWidth() {
        return document.body.getElementsByClassName("canvasRenderRelativeSize")[0].offsetWidth;
    }

    function onWindowResize() {
        camera.aspect = getRelativeWidth() / getRelativeHeight();
        camera.updateProjectionMatrix();

        renderer.setSize(getRelativeWidth(), getRelativeHeight());
    }

    function loadGraph() {
        var axesHelper = new THREE.AxesHelper(50);
        //console.log(axesHelper.position.x);
        //console.log(axesHelper.position.y);
        //console.log(axesHelper.position.z);
        scene.add(axesHelper);

        //var geometryPlane = new THREE.PlaneGeometry( 5, 5 );
        //var materialPlane = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
        //var plane = new THREE.Mesh( geometryPlane, materialPlane );

        //plane.position.y = 10;
        //plane.position.x = 10;

        //scene.add( plane );
        //--

        var gridHelper = new THREE.GridHelper(100, 10);
        //gridHelper.position.x = ghSize / 2 + 0.1;
        //gridHelper.position.y = 0;
        //gridHelper.position.z = ghSize / 2 + 0.1;
        scene.add(gridHelper);

        var files = sessionData.getSessionData();

        var filesGroupOrdered = files.sort(function (a, b) { return a.group - b.group });

        var groups = [];
        filesGroupOrdered.forEach(function(file) {
            if (groups.indexOf(file.group) == -1)
                groups.push(file.group);
        });

        var cGroupLimit = Math.ceil(Math.sqrt(groups.length));

        var lTotal = 0, cTotal = 0, higherL = 0, cG = 0;
        groups.forEach(function(group) {
            var filesOfGroup = files.filter(function(file) {
                return file.group == group;
            });

            var cLimit = Math.ceil(Math.sqrt(filesOfGroup.length));
            cLimit = cLimit + cTotal;

            var l = lTotal, c = cTotal;
            filesOfGroup.forEach(function(file) {
                if (c == cLimit) {
                    l++;
                    c = cTotal;
                }

                if (l > higherL)
                    higherL = l;

                file.x = c;
                file.z = l;

                c++;
            });

            cTotal = cLimit + 1;

            cG++;

            if (cG == cGroupLimit) {
                lTotal = higherL + 1 + 1;
                higherL = 0;
                cTotal = 0;
                cG = 0;
            }
        });

        var mostHighFileLine = 0;
        for (var i = 0; i < files.length; i++) {
            if (files[i].lines > mostHighFileLine)
                mostHighFileLine = files[i].lines;
        }

        var color = '';
        for (var i = 0; i < files.length; i++) {
            if (i == 0)
                color = colorPalette.pickUpColor();
            else if (files[i - 1].group != files[i].group)
                color = colorPalette.pickUpColor();

            var cube = drawCubeOnGraph(files[i].x, files[i].z, files[i].lines, color, mostHighFileLine, files[i].group);
            var hideButton = drawHideCubeButton(files[i].x, files[i].z, cube.geometry.parameters.height, color, files[i].group);

            hideButton.cubeId = cube.id;

            for (var j = 0; j < files[i].breakpoints.length; j++) {
                var torus = drawTorusOnGraph(files[i].x, files[i].z, cube.geometry.parameters.height, files[i].breakpoints[j].data, files[i].group);
                torus.cubeId = cube.id;

                scene.add(torus);
            }

            for (var j = 0; j < files[i].events.length; j++) {
                var square = drawTorusSquareOnGraph(files[i].x, files[i].z, cube.geometry.parameters.height, files[i].events[j].data, files[i].group);
                square.cubeId = cube.id;

                scene.add(square);
            }

            scene.add(cube);
            scene.add(hideButton);
        }
    }

    function resetGraph() {
        scene.remove.apply(scene, scene.children);
    }

    var camera = new THREE.PerspectiveCamera(45, 0, 1, 500);
    var scene = new THREE.Scene();
    var mouse = new THREE.Vector2();
    var raycaster = new THREE.Raycaster();
    var renderer = new THREE.WebGLRenderer();

    document.addEventListener("DOMContentLoaded", function () {
        renderer.setSize(getRelativeWidth(), getRelativeHeight());
        document.body.getElementsByClassName("canvasRenderRelativeSize")[0].appendChild(renderer.domElement);

        camera.position.set(60, 60, 60);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        var orbit = new THREE.OrbitControls(camera, renderer.domElement);
        orbit.enableZoom = true;

        loadGraph();

        //var cubeWithRintHeight = Math.floor(Math.random() * 31);
        //scene.add(drawCubeOnGraph(12, 15, 100, getRamdomColor()));

        //--

        //var geometrySphere = new THREE.SphereGeometry(0.5, 20, 20);
        //var materialSphere = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        //var sphere = new THREE.Mesh(geometrySphere, materialSphere);

        //sphere.position.y = 0.5;
        //sphere.position.x = 0.5 + 0.1 + 3;
        //sphere.position.z = 0.5 + 0.1 + 2;

        //scene.add(sphere);
        //--

        var intersected = null;

        document.body.getElementsByClassName("canvasRenderRelativeSize")[0].addEventListener('mousemove', onDocumentMouseMove, false);

        //--

        //var geometryTorus = new THREE.TorusGeometry(0.5, 0.2, 10, 30); //Ring 3d
        //var materialTorus = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        //var torus = new THREE.Mesh(geometryTorus, materialTorus);

        //torus.position.y = 0.5 + cubeWithRintHeight / 2;
        //torus.position.x = 0.5 + 0.1 + 12;
        //torus.position.z = 0.5 + 0.1 + 15;
        //torus.rotation.x = 1.6;//flip to horizontal

        //scene.add(torus);
        //--

        document.addEventListener('mousedown', onDocumentMouseDown, false);

        //--
        window.addEventListener('resize', onWindowResize, false);
        //--
        var animate = function () {
            requestAnimationFrame(animate);

            //--
            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                var iCubeOnGraph = -1;
                for (var i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.canHighlightOnMouseOver) {
                        iCubeOnGraph = i;
                        break;
                    }
                }

                if (iCubeOnGraph != -1 && intersected != intersects[iCubeOnGraph].object) {
                    if (intersected != null)
                        intersected.material.color.setHex(intersected.currentHex);

                    intersected = intersects[iCubeOnGraph].object;
                    intersected.currentHex = intersected.material.color.getHex();
                    intersected.material.color.setHex(0xff0000);
                }
            } else {
                if (intersected != null)
                    intersected.material.color.setHex(intersected.currentHex);

                intersected = null;
            }
            //--

            renderer.render(scene, camera);
        };

        onWindowResize();
        animate();

        //-----

        document.getElementsByClassName("reset-camera-button")[0].addEventListener("click", function () {
            camera.position.set(60, 60, 60);
            camera.lookAt(new THREE.Vector3(0, 0, 0));
        });

        //------------------------------

        var colorOptions = {
            Background: "#000000",
            Groups: colorPalette.defaultColorPaletteName
        };

        function changeColor() {
            scene.background = new THREE.Color(colorOptions.Background);
        };

        function changeGroupColor() {
            var groupBefore = undefined;
            var firstNodeOfGroup = undefined;
            var color = '';

            scene.traverse(function (node) {
                if (node instanceof THREE.Mesh && node.canScaleChange) {

                    if (groupBefore == undefined) {
                        groupBefore = node.group;
                        firstNodeOfGroup = node;

                        color = colorPalette.pickUpColor(colorOptions.Groups);
                    } else if (groupBefore != node.group) {
                        groupBefore = node.group;
                        firstNodeOfGroup = node;

                        color = colorPalette.pickUpColor(colorOptions.Groups);
                    } 

                    node.material.color = new THREE.Color(color);
                }
            });            
        };

        var guiColorOtions = new dat.GUI({ autoPlace: false });
        guiColorOtions.add(colorOptions, 'Groups', colorPalette.getColorPalatteArray()).onChange(changeGroupColor);
        guiColorOtions.addColor(colorOptions, 'Background').onChange(changeColor);

        document.getElementsByClassName("tool-box")[0].appendChild(guiColorOtions.domElement);

        document.getElementsByClassName("tool-colorchange")[0].addEventListener("click", function () {
            if (guiColorOtions.domElement.style.visibility == 'visible') {
                guiColorOtions.domElement.style.visibility = 'hidden';
                this.className = '';
            } else {
                guiColorOtions.domElement.style.visibility = 'visible';
                this.className = 'selected';
            }
        });

        //-------------------------------

        var scaleOptions = {
            cubeSpace: 1,
            groupSpace: 1,
            fileScale: 50
        };

        function changeCubeScale() {
            scene.traverse(function (node) {
                if (node instanceof THREE.Mesh) {
                    if (node.canScaleChange) {
                        node.position.x = node.initialCalculatedPositionX * scaleOptions.cubeSpace;
                        node.position.z = node.initialCalculatedPositionZ * scaleOptions.cubeSpace;
                    }
                }
            });
        };

        function changeGroupScale() {
            var groupBefore = undefined;
            var firstNodeOfGroup = undefined;

            scene.traverse(function (node) {
                if (node instanceof THREE.Mesh && node.canScaleChange) {

                    if (groupBefore == undefined) {
                        groupBefore = node.group;
                        firstNodeOfGroup = node;

                        node.position.x = node.initialCalculatedPositionX * scaleOptions.groupSpace;
                        node.position.z = node.initialCalculatedPositionZ * scaleOptions.groupSpace;
                    } else if (groupBefore != node.group) {
                        groupBefore = node.group;
                        firstNodeOfGroup = node;

                        node.position.x = node.initialCalculatedPositionX * scaleOptions.groupSpace;
                        node.position.z = node.initialCalculatedPositionZ * scaleOptions.groupSpace;
                    } else {
                        node.position.x = (firstNodeOfGroup.position.x - firstNodeOfGroup.initialCalculatedPositionX) + node.initialCalculatedPositionX;
                        node.position.z = (firstNodeOfGroup.position.z - firstNodeOfGroup.initialCalculatedPositionZ) + node.initialCalculatedPositionZ;
                    }
                }
            });
        };

        function changeFileScale() {
            scene.traverse(function (node) {
                if (node instanceof THREE.Mesh && node.canScaleChange) {

                    if (node.isCube != undefined) {
                        var height = node.lines * scaleOptions.fileScale / node.mostHighFileLine;

                        node.geometry = new THREE.BoxGeometry(node.xSize, height, node.zSize);;

                        var adjustToZeroAxisY = height / 2;
                        node.position.y = adjustToZeroAxisY;
                    } else if (node.isSphere != undefined) {
                        var relativeCube = scene.getObjectById(node.cubeId, true);
                        var height = relativeCube.geometry.parameters.height;

                        node.position.y = node.radius + node.topMargin + height;
                    } else if (node.isTorus != undefined) {
                        var relativeCube = scene.getObjectById(node.cubeId, true);
                        var height = relativeCube.geometry.parameters.height;

                        var adjustToZeroAxisY = height / 2;

                        node.position.y = node.topMargin + adjustToZeroAxisY;
                    }
                }
            });
        };

        var guiScaleOtions = new dat.GUI({ autoPlace: false });
        guiScaleOtions.add(scaleOptions, 'cubeSpace', 1, 5).onChange(changeCubeScale);
        guiScaleOtions.add(scaleOptions, 'groupSpace', 1, 5).onChange(changeGroupScale);
        guiScaleOtions.add(scaleOptions, 'fileScale', 10, 100).onChange(changeFileScale);

        document.getElementsByClassName("tool-box")[0].appendChild(guiScaleOtions.domElement);

        document.getElementsByClassName("tool-scalechange")[0].addEventListener("click", function () {
            if (guiScaleOtions.domElement.style.visibility == 'visible') {
                guiScaleOtions.domElement.style.visibility = 'hidden';
                this.className = '';
            } else {
                guiScaleOtions.domElement.style.visibility = 'visible';
                this.className = 'selected';
            }
        });

        //--

        var sessionSelect = document.getElementById("session-select");
        var sessionArray = sessionData.getSessionArray();
        for (let i = 0; i < sessionArray.length; i++) {
            var option = document.createElement('option');

            option.text = sessionArray[i];
            option.value = sessionArray[i];

            if (sessionArray[i] == sessionData.getDefaultSessionName())
                option.selected = true;

            sessionSelect.add(option);
        }

        sessionSelect.addEventListener("change", function () {
            sessionData.setDefaultSession(sessionSelect.selectedIndex);

            resetGraph();
            loadGraph();
        });
    });
</script>
<h2>Prototype</h2>
<br />
<label for="session-select">Sessions: </label>
<select id="session-select">
</select>
<br /><br />
<div class="tool-box fade-in">
    <div class="tool-box-header">
        <i class="fas fa-arrows-alt" aria-hidden="true" title="Move box."></i>
    </div>
    <ul class="tool-box-main">
        <li class="reset-camera-button"><i class="fas fa-undo fa-lg" title="Reset camera position"></i></li>
        <li class="tool-scalechange"><i class="fas fa-compress fa-lg" title="Change scales"></i></li>
        <li class="tool-colorchange"><i class="fas fa-palette fa-lg" title="Select background color"></i></li>
        <li class="tooltip-info">
            <i class="fas fa-info-circle fa-lg"></i>
            <div class="tooltip-text">info info <br /> nova linha</div>
        </li>
    </ul>
    <div class="tool-box-minimize">-</div>
</div>
<div class="detail-box fade-in">
    <div class="detail-box-header">
        <i class="fas fa-arrows-alt" aria-hidden="true"></i>
        <div class="detail-box-minimize">-</div>
    </div>
    <div class="detail-box-main"></div>
</div>
<div class="canvasRenderRelativeSize"></div>